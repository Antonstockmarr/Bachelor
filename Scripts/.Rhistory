tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(data[[i]]$ObsTime,1),]
tmp <- tmp.dat$Temperature
slr<-tmp.dat$Radiation*tmp.dat$SunHour
Hus<-data[[i]]
Hus$TemperatureIn<-NULL
Hus$TemperatureOut<-NULL
Hus$Temperature<-tmp
Hus$Radiation<-slr
names(Hus)
Xor <- Hus[ ,c("ObsTime","Energy","Temperature","Radiation")]
names(Xor) <- c("t","Qi","Te","G")
plotpoints<-matrix(rep(0,15),nrow = 3)
## Do daily values
Xday <- resample(Xor, 24*3600, tstart=trunc(Xor$t[1],"days"))
(pd<-summary(lm(Qi ~ Te + G, Xday)))
plotpoints[,1]<-(pd$coefficients[2,1]+1.96*c(0,pd$coefficients[2,2],-pd$coefficients[2,2]))
## Maybe take only a period and resample
## X <- Xor[period("2019-01-01",Xor$t,"2019-01-31"), ]
X <- resample(Xor, 3600, tstart=trunc(Xor$t[1],"days")+24*3600)
##X <- Xor
## Plot the series of interest
Xp <- X[period("2019-01-01",X$t,"2019-01-31"), ]
setpar("ts", mfrow=c(3,1))
plot(Xp$t,Xp$Qi,type="l")
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
axis.POSIXct(1,Xp$t,xaxt="s")
##----------------------------------------------------------------
## 4.1 ARMAX
##----------------------------------------------------------------
#install.packages('marima')
require(marima)
## We need to shift the inputs one lag forward to make it work
## Make a series of ones for the intercept estimate
X$One <- rep(1, nrow(X))
## Maybe lag the input vectors 1 step
#X$Te <- lagVec(X$Te, -1)
#X$G <- lagVec(X$G, -1)
## Try increasing the order
fit1 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=1, pMA=1, noLagPattern="One", pNoLag=1)
fit2 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=2, pMA=1, noLagPattern="One", pNoLag=1)
fit3 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=3, pMA=1, noLagPattern="One", pNoLag=1)
fit4 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=4, pMA=1, noLagPattern="One", pNoLag=1)
BIC(fit1)
BIC(fit2)
BIC(fit3)
BIC(fit4)
summary(fit1)
summary(fit2)
summary(fit3)
(h1<-HLC.Qi.ARX(fit1))
(h2<-HLC.Qi.ARX(fit2))
(h3<-HLC.Qi.ARX(fit3))
(h4<-HLC.Qi.ARX(fit4))
plotpoints[,2]<--1*(h1$HLC.Ta+1.96*c(0,sqrt(h1$VarHLC.Ta),-sqrt(h1$VarHLC.Ta)))
plotpoints[,3]<--1*(h2$HLC.Ta+1.96*c(0,sqrt(h2$VarHLC.Ta),-sqrt(h2$VarHLC.Ta)))
plotpoints[,4]<--1*(h3$HLC.Ta+1.96*c(0,sqrt(h3$VarHLC.Ta),-sqrt(h3$VarHLC.Ta)))
plotpoints[,5]<--1*(h4$HLC.Ta+1.96*c(0,sqrt(h4$VarHLC.Ta),-sqrt(h4$VarHLC.Ta)))
plot(plotpoints[1,])
plot(plotpoints[1,],ylim=plotpoints)
plot(plotpoints[1,],ylim=range(plotpoints))
lines(c(i,i),c(plotpoints[2,i],plotpoints[3,i]),col=2)
for(i in 1:5){
lines(c(i,i),c(plotpoints[2,i],plotpoints[3,i]),col=2)
}
i<-20
tmp.dat <- weather[(weather$ObsTime >= head(data[[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(data[[i]]$ObsTime,1),]
tmp <- tmp.dat$Temperature
slr<-tmp.dat$Radiation*tmp.dat$SunHour
Hus<-data[[i]]
Hus$TemperatureIn<-NULL
Hus$TemperatureOut<-NULL
Hus$Temperature<-tmp
Hus$Radiation<-slr
names(Hus)
Xor <- Hus[ ,c("ObsTime","Energy","Temperature","Radiation")]
names(Xor) <- c("t","Qi","Te","G")
plotpoints<-matrix(rep(0,15),nrow = 3)
## Do daily values
Xday <- resample(Xor, 24*3600, tstart=trunc(Xor$t[1],"days"))
(pd<-summary(lm(Qi ~ Te + G, Xday)))
plotpoints[,1]<-(pd$coefficients[2,1]+1.96*c(0,pd$coefficients[2,2],-pd$coefficients[2,2]))
## Maybe take only a period and resample
## X <- Xor[period("2019-01-01",Xor$t,"2019-01-31"), ]
X <- resample(Xor, 3600, tstart=trunc(Xor$t[1],"days")+24*3600)
##X <- Xor
## Plot the series of interest
Xp <- X[period("2019-01-01",X$t,"2019-01-31"), ]
setpar("ts", mfrow=c(3,1))
plot(Xp$t,Xp$Qi,type="l")
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
axis.POSIXct(1,Xp$t,xaxt="s")
##----------------------------------------------------------------
## 4.1 ARMAX
##----------------------------------------------------------------
#install.packages('marima')
require(marima)
## We need to shift the inputs one lag forward to make it work
## Make a series of ones for the intercept estimate
X$One <- rep(1, nrow(X))
## Maybe lag the input vectors 1 step
#X$Te <- lagVec(X$Te, -1)
#X$G <- lagVec(X$G, -1)
## Try increasing the order
fit1 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=1, pMA=1, noLagPattern="One", pNoLag=1)
fit2 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=2, pMA=1, noLagPattern="One", pNoLag=1)
fit3 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=3, pMA=1, noLagPattern="One", pNoLag=1)
fit4 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=4, pMA=1, noLagPattern="One", pNoLag=1)
BIC(fit1)
BIC(fit2)
BIC(fit3)
BIC(fit4)
summary(fit1)
summary(fit2)
summary(fit3)
(h1<-HLC.Qi.ARX(fit1))
(h2<-HLC.Qi.ARX(fit2))
(h3<-HLC.Qi.ARX(fit3))
(h4<-HLC.Qi.ARX(fit4))
plotpoints[,2]<--1*(h1$HLC.Ta+1.96*c(0,sqrt(h1$VarHLC.Ta),-sqrt(h1$VarHLC.Ta)))
plotpoints[,3]<--1*(h2$HLC.Ta+1.96*c(0,sqrt(h2$VarHLC.Ta),-sqrt(h2$VarHLC.Ta)))
plotpoints[,4]<--1*(h3$HLC.Ta+1.96*c(0,sqrt(h3$VarHLC.Ta),-sqrt(h3$VarHLC.Ta)))
plotpoints[,5]<--1*(h4$HLC.Ta+1.96*c(0,sqrt(h4$VarHLC.Ta),-sqrt(h4$VarHLC.Ta)))
plot(plotpoints[1,],ylim=range(plotpoints))
for(i in 1:5){
lines(c(i,i),c(plotpoints[2,i],plotpoints[3,i]),col=2)
}
acfccfPlot(fit2, X)
val <- HLC.Qi.ARX(fit2)
## Standard error
sqrt(val$VarHLC.Ta)
val$HLC.Ta + c(-1,1) * 1.96 * sqrt(val$VarHLC.Ta)
## Plot the series of interest
plot(fit2$residuals)
tmp <- X
tmp$residuals <- NA
tmp[(nrow(tmp) - length(fit2$residuals) + 1):nrow(tmp), "residuals"] <- fit2$residuals
Xp <- tmp[period("2019-01-01",tmp$t,"2019-01-31"), ]
setpar("ts", mfrow=c(4,1))
plot(Xp$t,Xp$residuals,type="l")
abline(h=0)
plot(Xp$t,Xp$Qi,type="l")
abline(h=mean(Xp$Qi))
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
axis.POSIXct(1,Xp$t,xaxt="s")
##----------------------------------------------------------------
## 3.4 HLC and step response
##----------------------------------------------------------------
## The step response for each of the inputs
## Use your best fit
stepResponseARX(fit2,X,"Te")
stepResponseARX(fit2,X,"G")
##----------------------------------------------------------------
## Calculate the estimated HLC-value and gA-value for the box based on the estimated steady-state reponse for Ti and Te, for G.
## Use your best fit. See the function in the file "r/functions/HLC.Qi.ARX.R"
HLC.Qi.ARX(fit2)
## Calculate the fourier series
X$tod <- as.POSIXlt(X$t)$hour
X <- cbind(X, fs(X$tod/24, nharmonics=3))
names(X)
## Plot the series of interest
Xp <- X[period("2019-01-01",X$t,"2019-01-31"), ]
setpar("ts", mfrow=c(5,1))
plot(Xp$t,Xp$Qi,type="l")
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
plot(Xp$t,Xp$sin_1,type="l")
lines(Xp$t,Xp$cos_1)
plot(Xp$t,Xp$sin_2,type="l")
lines(Xp$t,Xp$cos_2)
axis.POSIXct(1,Xp$t,xaxt="s")
## Try increasing the order
outName <- 'Qi'
inNames <- c('One','Te','G',pst('sin_',1:2),pst('cos_',1:2))
noLagPattern <- "One|sin|cos"
pNoLag <- 1
fit1 <- estimateARMAX(outName, inNames, pAR=1, pMA=1, noLagPattern, pNoLag)
fit2 <- estimateARMAX(outName, inNames, pAR=2, pMA=1, noLagPattern, pNoLag)
fit3 <- estimateARMAX(outName, inNames, pAR=3, pMA=1, noLagPattern, pNoLag)
BIC(fit1)
BIC(fit2)
BIC(fit3)
fit4 <- estimateARMAX(outName, inNames, pAR=4, pMA=1, noLagPattern, pNoLag)
BIC(fit4)
BIC(fit3)
BIC(fit2)
HLC.Qi.ARX(fit4)
HLC.Qi.ARX(fit3)
summary(fit3)
acfccfPlot(fit2, X)
i<-6
tmp.dat <- weather[(weather$ObsTime >= head(data[[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(data[[i]]$ObsTime,1),]
tmp <- tmp.dat$Temperature
slr<-tmp.dat$Radiation*tmp.dat$SunHour
Hus<-data[[i]]
Hus$TemperatureIn<-NULL
Hus$TemperatureOut<-NULL
Hus$Temperature<-tmp
Hus$Radiation<-slr
names(Hus)
Xor <- Hus[ ,c("ObsTime","Energy","Temperature","Radiation")]
names(Xor) <- c("t","Qi","Te","G")
plotpoints<-matrix(rep(0,15),nrow = 3)
## Do daily values
Xday <- resample(Xor, 24*3600, tstart=trunc(Xor$t[1],"days"))
(pd<-summary(lm(Qi ~ Te + G, Xday)))
plotpoints[,1]<-(pd$coefficients[2,1]+1.96*c(0,pd$coefficients[2,2],-pd$coefficients[2,2]))
## Maybe take only a period and resample
## X <- Xor[period("2019-01-01",Xor$t,"2019-01-31"), ]
X <- resample(Xor, 3600, tstart=trunc(Xor$t[1],"days")+24*3600)
##X <- Xor
## Plot the series of interest
Xp <- X[period("2019-01-01",X$t,"2019-01-31"), ]
setpar("ts", mfrow=c(3,1))
plot(Xp$t,Xp$Qi,type="l")
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
axis.POSIXct(1,Xp$t,xaxt="s")
##----------------------------------------------------------------
## 4.1 ARMAX
##----------------------------------------------------------------
#install.packages('marima')
require(marima)
## We need to shift the inputs one lag forward to make it work
## Make a series of ones for the intercept estimate
X$One <- rep(1, nrow(X))
## Maybe lag the input vectors 1 step
#X$Te <- lagVec(X$Te, -1)
#X$G <- lagVec(X$G, -1)
## Try increasing the order
fit1 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=1, pMA=1, noLagPattern="One", pNoLag=1)
fit2 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=2, pMA=1, noLagPattern="One", pNoLag=1)
fit3 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=3, pMA=1, noLagPattern="One", pNoLag=1)
fit4 <- estimateARMAX(outName='Qi', inNames=c('One','Te','G'), pAR=4, pMA=1, noLagPattern="One", pNoLag=1)
BIC(fit1)
BIC(fit2)
BIC(fit3)
BIC(fit4)
summary(fit1)
summary(fit2)
summary(fit3)
(h1<-HLC.Qi.ARX(fit1))
(h2<-HLC.Qi.ARX(fit2))
(h3<-HLC.Qi.ARX(fit3))
(h4<-HLC.Qi.ARX(fit4))
plotpoints[,2]<--1*(h1$HLC.Ta+1.96*c(0,sqrt(h1$VarHLC.Ta),-sqrt(h1$VarHLC.Ta)))
plotpoints[,3]<--1*(h2$HLC.Ta+1.96*c(0,sqrt(h2$VarHLC.Ta),-sqrt(h2$VarHLC.Ta)))
plotpoints[,4]<--1*(h3$HLC.Ta+1.96*c(0,sqrt(h3$VarHLC.Ta),-sqrt(h3$VarHLC.Ta)))
plotpoints[,5]<--1*(h4$HLC.Ta+1.96*c(0,sqrt(h4$VarHLC.Ta),-sqrt(h4$VarHLC.Ta)))
plot(plotpoints[1,],ylim=range(plotpoints))
for(i in 1:5){
lines(c(i,i),c(plotpoints[2,i],plotpoints[3,i]),col=2)
}
acfccfPlot(fit2, X)
val <- HLC.Qi.ARX(fit2)
## Standard error
sqrt(val$VarHLC.Ta)
val$HLC.Ta + c(-1,1) * 1.96 * sqrt(val$VarHLC.Ta)
## Plot the series of interest
plot(fit2$residuals)
tmp <- X
tmp$residuals <- NA
tmp[(nrow(tmp) - length(fit2$residuals) + 1):nrow(tmp), "residuals"] <- fit2$residuals
Xp <- tmp[period("2019-01-01",tmp$t,"2019-01-31"), ]
setpar("ts", mfrow=c(4,1))
plot(Xp$t,Xp$residuals,type="l")
abline(h=0)
plot(Xp$t,Xp$Qi,type="l")
abline(h=mean(Xp$Qi))
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
axis.POSIXct(1,Xp$t,xaxt="s")
##----------------------------------------------------------------
## 3.4 HLC and step response
##----------------------------------------------------------------
## The step response for each of the inputs
## Use your best fit
stepResponseARX(fit2,X,"Te")
stepResponseARX(fit2,X,"G")
##----------------------------------------------------------------
## Calculate the estimated HLC-value and gA-value for the box based on the estimated steady-state reponse for Ti and Te, for G.
## Use your best fit. See the function in the file "r/functions/HLC.Qi.ARX.R"
HLC.Qi.ARX(fit2)
##----------------------------------------------------------------
## Use fourier series as input
## Calculate the fourier series
X$tod <- as.POSIXlt(X$t)$hour
X <- cbind(X, fs(X$tod/24, nharmonics=3))
names(X)
## Plot the series of interest
Xp <- X[period("2019-01-01",X$t,"2019-01-31"), ]
setpar("ts", mfrow=c(5,1))
plot(Xp$t,Xp$Qi,type="l")
plot(Xp$t,Xp$Te,type="l")
plot(Xp$t,Xp$G,type="l")
plot(Xp$t,Xp$sin_1,type="l")
lines(Xp$t,Xp$cos_1)
plot(Xp$t,Xp$sin_2,type="l")
lines(Xp$t,Xp$cos_2)
axis.POSIXct(1,Xp$t,xaxt="s")
## Try increasing the order
outName <- 'Qi'
inNames <- c('One','Te','G',pst('sin_',1:2),pst('cos_',1:2))
noLagPattern <- "One|sin|cos"
pNoLag <- 1
fit1 <- estimateARMAX(outName, inNames, pAR=1, pMA=1, noLagPattern, pNoLag)
fit2 <- estimateARMAX(outName, inNames, pAR=2, pMA=1, noLagPattern, pNoLag)
fit3 <- estimateARMAX(outName, inNames, pAR=3, pMA=1, noLagPattern, pNoLag)
fit4 <- estimateARMAX(outName, inNames, pAR=4, pMA=1, noLagPattern, pNoLag)
BIC(fit1)
BIC(fit2)
BIC(fit3)
BIC(fit4)
summary(fit1)
summary(fit2)
summary(fit3)
summary(fit4)
HLC.Qi.ARX(fit1)
HLC.Qi.ARX(fit2)
HLC.Qi.ARX(fit3)
HLC.Qi.ARX(fit4)
acfccfPlot(fit2, X)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("data.R")
source("TrainTest.R")
source("BSplines.R")
# Daily predictions ----------------------------------
k <-1:n
Long <- k[Datalengths>=360]
Short <- k[Datalengths<360]
#Flipping WeatherCons
for(i in 1:n){
k<-dim(weatherCons[[i]])[1]
weatherCons[[i]]<-weatherCons[[i]][k:1,]
}
# Defining data used for modelling
model.data <- weatherCons
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
ttd<-TrainTest(model.data,31)
ttm<-TrainTest(weatherCons,31)
mondays<-which(weekdays(ttm[[2]][[1]]$Date)=="Monday")-.5
# Weatherplots for daily predictions
par(mfrow=c(3,1))
plot(ttd[[2]][[1]]$Temperature,type='o',lwd=3,ylab=expression(paste("Temperature [", degree, "C]")),xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
plot(ttd[[2]][[1]]$Radiation,type='o',lwd=3,ylab=expression(paste("Solar Radiation [",W/m^2,"]")),xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
plot(ttd[[2]][[1]]$WindDirection,type='o',lwd=3,ylab="Wind Direction [degrees]",xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
lmMultipleNoP <- vector(mode = "list", length = n)
par(mfrow = c(1,1))
k<-0
for (i in c(18,55)) {
k<-k+1
if(k<=length(Long)){
print(paste('Modelling long house ',i))
}else{
print(paste('Modelling short house ',i))
}
model.tmp <- ttd[[1]][[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
newData = ttd[[2]][[i]]
Splinetest <- BSplines(newData$WindDirection)
test.wind <- Splinetest*newData$WindSpeed
newData$North <- test.wind[,3]
newData$East <- test.wind[,4]
newData$South <- test.wind[,1]
newData$West <- test.wind[,2]
newData$Consumption<-NULL
Pred<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "prediction", level = 0.95))
if(k>length(Long)){
mm<-paste("Short house: ",i)
}else{
mm<-paste("Long house: ",i)
}
# Statistisk plot
plot(Pred$fit,type='l',ylim=range(Pred$lwr,Pred$upr),main=mm,ylab="Consumption [kWh]",xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
lines(Pred$upr,lty=2)
lines(Pred$lwr,lty=2)
lines(ttd[[2]][[i]]$Consumption,lty=1,col=2)
abline(v=mondays,lty=3,lwd=2,col=Wcol[3])
legend(x = "topleft", legend = c("Prediction", "95% PI", "Data","Monday"), lty = c(1,2,1,3), col = c(1,1,2,Wcol[3]),lwd=c(1,1,1,2))
# Kundeplot(s)
PredK<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "prediction", level = 1/3))
plot(PredK$fit,type='n',ylim=range(PredK$lwr,PredK$upr,ttd[[2]][[i]]$Consumption),main=mm,ylab="Consumption [kWh]",xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
ylim=c(-100,1200)
polygon(c(1:31, 31, 1), y= c(PredK$lwr,ylim[1],ylim[1]), col = Wcol[2], lty=0)
polygon(c(1:31, 31, 1), y= c(PredK$upr,ylim[2],ylim[2]), col = Wcol[4], lty=0)
polygon(c(1:31, 31:1), y= c(PredK$lwr, rev(PredK$upr)), col = Wcol[3], lty=0)
lines(1:31,ttd[[2]][[i]]$Consumption,type='o',col=1,lwd=3)
cols<-rep(Wcol[3],length(ttd[[2]][[i]]$Consumption))
cols[ttd[[2]][[i]]$Consumption<PredK$lwr]<-Wcol[2]
cols[ttd[[2]][[i]]$Consumption>PredK$upr]<-Wcol[4]
barplot(ttd[[2]][[i]]$Consumption,col=cols,main=mm, ylab="Consumption [kWh]",xlab="January 2019 [days]")
}
# Hourly Predictions ----------------------------------------
# Arima
for(i in 1:n){
nas<-which(!is.na(data[[i]]$Flow))
tmp.dat<-data[[i]][nas[1]:tail(nas,1),]
nas<-which(is.na(tmp.dat$Flow))
m<-dim(tmp.dat)[2]
for(j in nas){
tmp.dat[j,2:m]<-(data[[i]][j-1,2:m]+data[[i]][j+1,2:m])/2
}
data[[i]]<-tmp.dat
}
for(i in 1:n){
k<-dim(data[[i]])[1]
data[[i]]<-data[[i]][k:1,]
}
k<-dim(weather)[1]
weather <- weather[k:1,]
tth<-TrainTest(data,14*24)
i<-55
for(i in 55){
midnight<-which(hour(tth[[2]][[i]]$ObsTime)==0)+length(tth[[1]][[i]]$ObsTime)
a <- 12
tmp.dat <- weather[(weather$ObsTime >= head(tth[[1]][[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(tth[[1]][[i]]$ObsTime,1),]
tmp <- tmp.dat$Temperature
Temperature <- (tmp<a)*(a-tmp)
arima.dat <- data.frame(Temperature = Temperature, Consumption = cc*tth[[1]][[i]]$CoolingDegree*tth[[1]][[i]]$Volume)
#A <- arima(arima.dat$Consumption, order =c(1,0,1), seasonal = list(order = c(1,1,1), period = 24),xreg=arima.dat$Temperature)
tmp.dat <- weather[(weather$ObsTime >= head(tth[[2]][[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(tth[[2]][[i]]$ObsTime,1),]
tmp <- tmp.dat$Temperature
TemperatureP <- (tmp<a)*(a-tmp)
p<-predict(A,n.ahead=length(TemperatureP),se.fit=TRUE,newxreg = TemperatureP,interval="prediction")
plot(p$pred,ylim=c(min(p$pred-2*p$se,tth[[2]][[i]]$CoolingDegree*tth[[2]][[i]]$Volume*cc),max(p$pred+2*p$se,tth[[2]][[i]]$CoolingDegree*tth[[2]][[i]]$Volume*cc)),xaxt='n',xlab="January 2019",ylab="Consumption",main=paste("Long house: ",i))
axis(1, at=c(9150,(9150+9490)/2,9490), labels=c("17th","24th","31st"))
lines(p$pred+2*p$se,lty=2)
lines(p$pred-2*p$se,lty=2)
lines(length(tth[[1]][[i]]$ObsTime)+(1:length(tth[[2]][[i]]$ObsTime)),cc*tth[[2]][[i]]$CoolingDegree*tth[[2]][[i]]$Volume,col=2)
abline(v=midnight,lty=3,lwd=2,col=Wcol[3])
legend(x = "topleft", legend = c("Prediction", "95% PI", "Data","Midnight"), lty = c(1,2,1,3), col = c(1,1,2,Wcol[3]),lwd=c(1,1,1,2))
# Smoothing experiment
Scons1<-tth[[1]][[i]]$CoolingDegree*tth[[1]][[i]]$Volume*cc
Scons2<-tth[[2]][[i]]$CoolingDegree*tth[[2]][[i]]$Volume*cc
print(paste("Antal smoothings for hus",i,": Train:",sum(Scons1==0),"af",length(Scons1),"Test",sum(Scons2==0),"af",length(Scons2)))
# Smoothing (n?r en v?rdi er nul, udlignes det med punktet f?r)
for(j in rev(which(Scons1==0))){
if(j!=1){
Scons1[c(j-1,j)]<-Scons1[j-1]/2
}
}
for(j in rev(which(Scons2==0))){
if(j!=1){
Scons2[c(j-1,j)]<-Scons2[j-1]/2
}
}
arima.dat <- data.frame(Temperature = Temperature, Consumption = Scons1)
A <- arima(arima.dat$Consumption, order =c(1,0,1), seasonal = list(order = c(1,1,1), period = 24),xreg=arima.dat$Temperature)
p<-predict(A,n.ahead=length(TemperatureP),se.fit=TRUE,newxreg = TemperatureP)
plot(p$pred,ylim=c(min(p$pred-2*p$se,Scons2),max(p$pred+2*p$se,Scons2)),xaxt='n',xlab="January 2019",ylab="Consumption",main=paste("Long house: ",i))
axis(1, at=c(length(tth[[1]][[i]]$Obstime),length(tth[[1]][[i]]$Obstime)+170,length(tth[[1]][[i]]$Obstime)+340), labels=c("17th","24th","31st"))
lines(p$pred+2*p$se,lty=2)
lines(p$pred-2*p$se,lty=2)
lines(length(tth[[1]][[i]]$ObsTime)+(1:length(tth[[2]][[i]]$ObsTime)),Scons2,col=2)
abline(v=midnight,lty=3,lwd=2,col=Wcol[3])
legend(x = "topleft", legend = c("Prediction", "95% PI", "Data","Midnight"), lty = c(1,2,1,3), col = c(1,1,2,Wcol[3]),lwd=c(1,1,1,2))
}
#weather from test period:
source('C:/Users/mikke/Desktop/6. sem/Bach/Bachelor-f19/Scripts/Predictions.R', echo=TRUE)
#weather from test period:
tmp.dat <- weather[(weather$ObsTime >= head(tth[[2]][[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(tth[[2]][[i]]$ObsTime,1),]
tmp.dat
tmp.dat <- weather[(weather$ObsTime >= head(tth[[2]][[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(tth[[2]][[i]]$ObsTime,1),]
plot(tmp.dat$Temperature,type='o',lwd=3,ylab=expression(paste("Temperature [", degree, "C]")),xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
plot(tmp.dat$Radiation,type='o',lwd=3,ylab=expression(paste("Solar Radiation [",W/m^2,"]")),xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
plot(tmp.dat$WindDirection,type='o',lwd=3,ylab="Wind Direction [degrees]",xlab="January 2019 [days]",xaxt='n')
axis(1, at=c(1,15,31), labels=c("1st","15th","31st"))
par(mfrow=c(1,3))
plot(tmp.dat$Temperature,type='o',lwd=3,ylab=expression(paste("Temperature [", degree, "C]")),xlab="January 2019 [hours]")
plot(tmp.dat$Radiation,type='o',lwd=3,ylab=expression(paste("Solar Radiation [",W/m^2,"]")),xlab="January 2019 [hours]")
plot(tmp.dat$WindDirection,type='o',lwd=3,ylab="Wind Direction [degrees]",xlab="January 2019 [hours]"
plot(tmp.dat$WindDirection,type='o',lwd=3,ylab="Wind Direction [degrees]",xlab="January 2019 [hours]"
plot(tmp.dat$WindDirection,type='o',lwd=3,ylab="Wind Direction [degrees]",xlab="January 2019 [hours]")
par(mfrow=c(3,1))
plot(tmp.dat$Temperature,type='o',lwd=3,ylab=expression(paste("Temperature [", degree, "C]")),xlab="January 2019 [hours]")
plot(tmp.dat$Radiation,type='o',lwd=3,ylab=expression(paste("Solar Radiation [",W/m^2,"]")),xlab="January 2019 [hours]")
plot(tmp.dat$WindDirection,type='o',lwd=3,ylab="Wind Direction [degrees]",xlab="January 2019 [hours]")
plot(tmp.dat$Temperature,type='o',lwd=1,ylab=expression(paste("Temperature [", degree, "C]")),xlab="January 2019 [hours]")
plot(tmp.dat$Radiation,type='o',lwd=1,ylab=expression(paste("Solar Radiation [",W/m^2,"]")),xlab="January 2019 [hours]")
plot(tmp.dat$WindDirection,type='o',lwd=1,ylab="Wind Direction [degrees]",xlab="January 2019 [hours]")
source('C:/Users/mikke/Desktop/6. sem/Bach/Bachelor-f19/Scripts/Predictions.R', echo=TRUE)
