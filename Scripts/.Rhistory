(bics[4]<-BIC(fit3))
(bics[5]<-BIC(fit4))
(bics[6]<-BIC(fit5))
(bics[7]<-BIC(fit6))
(bics[8]<-BIC(fit7))
summary(fit1)
summary(fit2)
summary(fit3)
summary(fit4)
(h1<-HLC.Qi.ARX(fit1))
(h2<-HLC.Qi.ARX(fit2))
(h3<-HLC.Qi.ARX(fit3))
(h4<-HLC.Qi.ARX(fit4))
(h5<-HLC.Qi.ARX(fit5))
(h6<-HLC.Qi.ARX(fit6))
(h7<-HLC.Qi.ARX(fit7))
plotpoints[,2]<--1*(h1$HLC.Ta+1.96*c(0,sqrt(h1$VarHLC.Ta),-sqrt(h1$VarHLC.Ta)))
plotpoints[,3]<--1*(h2$HLC.Ta+1.96*c(0,sqrt(h2$VarHLC.Ta),-sqrt(h2$VarHLC.Ta)))
plotpoints[,4]<--1*(h3$HLC.Ta+1.96*c(0,sqrt(h3$VarHLC.Ta),-sqrt(h3$VarHLC.Ta)))
plotpoints[,5]<--1*(h4$HLC.Ta+1.96*c(0,sqrt(h4$VarHLC.Ta),-sqrt(h4$VarHLC.Ta)))
plotpoints[,6]<--1*(h5$HLC.Ta+1.96*c(0,sqrt(h5$VarHLC.Ta),-sqrt(h5$VarHLC.Ta)))
plotpoints[,7]<--1*(h6$HLC.Ta+1.96*c(0,sqrt(h6$VarHLC.Ta),-sqrt(h6$VarHLC.Ta)))
plotpoints[,8]<--1*(h7$HLC.Ta+1.96*c(0,sqrt(h7$VarHLC.Ta),-sqrt(h7$VarHLC.Ta)))
BestIndex=which(bics==min(bics[-1]))
Delta<-plotpoints[3,]-plotpoints[2,]
BestIndex2=which(Delta==min(Delta[-1]))
plot(c(.5,2,3.5),plotpoints[1,c(1,BestIndex,BestIndex2)],ylim=range(plotpoints),xlim=c(0,4),ylab="HCL incl. 95% CI",xaxt='n',xlab=paste("House:",i))
lines(c(.5,.5),c(plotpoints[2,1],plotpoints[3,1]),col=Wcol[4])
lines(c(2,2),c(plotpoints[2,BestIndex],plotpoints[3,BestIndex]),col=Wcol[4])
lines(c(3.5,3.5),c(plotpoints[2,BestIndex2],plotpoints[3,BestIndex2]),col=Wcol[4])
axis(1, at=c(.5,2,3.5), labels=c("Day","BIC","CI"))
stepResponseARX(fit7,X,"Te")
# Med Fourier
for(i in c(55,18,6)){
tmp.dat <- weather[(weather$ObsTime >= head(data[[i]]$ObsTime,1)),]
tmp.dat <- tmp.dat[tmp.dat$ObsTime <= tail(data[[i]]$ObsTime,1),]
tmp <- tmp.dat$Temperature
slr<-tmp.dat$Radiation*tmp.dat$SunHour
Hus<-data[[i]]
Hus$TemperatureIn<-NULL
Hus$TemperatureOut<-NULL
Hus$Temperature<-tmp
Hus$Radiation<-slr
names(Hus)
Xor <- Hus[ ,c("ObsTime","Energy","Temperature","Radiation")]
names(Xor) <- c("t","Qi","Te","G")
plotpoints<-matrix(rep(0,15),nrow = 3)
## Do daily values
Xday <- resample(Xor, 24*3600, tstart=trunc(Xor$t[1],"days"))
(pd<-summary(lm(Qi ~ Te + G, Xday)))
plotpoints[,1]<-(pd$coefficients[2,1]+1.96*c(0,-pd$coefficients[2,2],+pd$coefficients[2,2]))
## Maybe take only a period and resample
## X <- Xor[period("2019-01-01",Xor$t,"2019-01-31"), ]
X <- resample(Xor, 3600, tstart=trunc(Xor$t[1],"days")+24*3600)
##X <- Xor
## Plot the series of interest
Xp <- X[period("2019-01-01",X$t,"2019-01-31"), ]
# setpar("ts", mfrow=c(3,1))
# plot(Xp$t,Xp$Qi,type="l")
# plot(Xp$t,Xp$Te,type="l")
# plot(Xp$t,Xp$G,type="l")
# axis.POSIXct(1,Xp$t,xaxt="s")
##----------------------------------------------------------------
## 4.1 ARMAX
##----------------------------------------------------------------
#install.packages('marima')
require(marima)
## We need to shift the inputs one lag forward to make it work
## Make a series of ones for the intercept estimate
X$One <- rep(1, nrow(X))
X$tod <- as.POSIXlt(X$t)$hour
X <- cbind(X, fs(X$tod/24, nharmonics=3))
## Maybe lag the input vectors 1 step
#X$Te <- lagVec(X$Te, -1)
#X$G <- lagVec(X$G, -1)
## Try increasing the order
outName <- 'Qi'
inNames <- c('One','Te','G',pst('sin_',1:3),pst('cos_',1:3))
noLagPattern <- "One|sin|cos"
pNoLag <- 1
fit1 <- estimateARMAX(outName, inNames, pAR=1, pMA=1, noLagPattern, pNoLag)
fit2 <- estimateARMAX(outName, inNames, pAR=2, pMA=1, noLagPattern, pNoLag)
fit3 <- estimateARMAX(outName, inNames, pAR=3, pMA=1, noLagPattern, pNoLag)
fit4 <- estimateARMAX(outName, inNames, pAR=4, pMA=1, noLagPattern, pNoLag)
bics<-rep(0,5)
(bics[2]<-BIC(fit1))
(bics[3]<-BIC(fit2))
(bics[4]<-BIC(fit3))
(bics[5]<-BIC(fit4))
summary(fit1)
summary(fit2)
summary(fit3)
summary(fit4)
(h1<-HLC.Qi.ARX(fit1))
(h2<-HLC.Qi.ARX(fit2))
(h3<-HLC.Qi.ARX(fit3))
(h4<-HLC.Qi.ARX(fit4))
plotpoints[,2]<--1*(h1$HLC.Ta+1.96*c(0,sqrt(h1$VarHLC.Ta),-sqrt(h1$VarHLC.Ta)))
plotpoints[,3]<--1*(h2$HLC.Ta+1.96*c(0,sqrt(h2$VarHLC.Ta),-sqrt(h2$VarHLC.Ta)))
plotpoints[,4]<--1*(h3$HLC.Ta+1.96*c(0,sqrt(h3$VarHLC.Ta),-sqrt(h3$VarHLC.Ta)))
plotpoints[,5]<--1*(h4$HLC.Ta+1.96*c(0,sqrt(h4$VarHLC.Ta),-sqrt(h4$VarHLC.Ta)))
BestIndex=which(bics==min(bics[-1]))
Delta<-plotpoints[3,]-plotpoints[2,]
BestIndex2=which(Delta==min(Delta[-1]))
plot(c(.5,2,3.5),plotpoints[1,c(1,BestIndex,BestIndex2)],ylim=range(plotpoints),xlim=c(0,4),ylab="HCL incl. 95% CI",xaxt='n',xlab=paste("House:",i))
lines(c(.5,.5),c(plotpoints[2,1],plotpoints[3,1]),col=Wcol[4])
lines(c(2,2),c(plotpoints[2,BestIndex],plotpoints[3,BestIndex]),col=Wcol[4])
lines(c(3.5,3.5),c(plotpoints[2,BestIndex2],plotpoints[3,BestIndex2]),col=Wcol[4])
axis(1, at=c(.5,2,3.5), labels=c("Day","BIC","CI"))
}
source('C:/Users/mikke/Desktop/6. sem/Bach/Bachelor-f19/Scripts/Piecewise-opti.R', echo=TRUE)
source('C:/Users/mikke/Desktop/6. sem/Bach/Bachelor-f19/Scripts/Consumption-plots.R', echo=TRUE)
par(mfrow=c(1,2))
# Plotting the first house
AnalyzeConsumption(houselist=55,makeplot=TRUE)
AnalyzeConsumption(houselist=18,makeplot=TRUE)
source('C:/Users/mikke/Desktop/6. sem/Bach/Bachelor-f19/Scripts/BreakPoint.R', echo=TRUE)
source('C:/Users/mikke/Desktop/6. sem/Bach/Bachelor-f19/Scripts/MultipleRegression.R', echo=TRUE)
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
par(mar=c(3,3,2,1), mgp=c(2,0.7,0),mfrow=c(1,1),xpd=FALSE)
source("data.R")
source("stepP.R")
source("BSplines.R")
source("CirclePlot.R")
# Initializing vectors containing "long" and "short" houses
k <-1:n
Long <- k[Datalengths>=360]
Short <- k[Datalengths<360]
#Flip WeatherCons
for(i in 1:n){
k<-dim(weatherCons[[i]])[1]
weatherCons[[i]]<-weatherCons[[i]][k:1,]
}
# Defining data used for modelling
model.data <- weatherCons
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
# Full regression model ---------------------------------------------------
# Initializing
lmMultipleFull <- vector(mode = "list", length = n)
lmFull_est_L <- matrix(rep(0,17*length(Long)),nrow = length(Long))
lmFull_p_L <- matrix(rep(0,17*length(Long)),nrow = length(Long))
lmFull_est_S <- matrix(rep(0,15*length(Short)),nrow = length(Short))
lmFull_p_S <- matrix(rep(0,15*length(Short)),nrow = length(Short))
# Full regression model for "long" houses
for (i in c(55,18)) {
print(paste('Full Model of long house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
# Splines
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleFull[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+MeanSeaLevelPressure+Radiation+WinterBreak+SpringBreak+AutumnBreak+ChristmasBreak+Weekend, data = model.tmp)
# Saving coefficients
lmFull_est_L[match(i,Long),] <- summary(lmMultipleFull[[i]])$coefficients[,1]
lmFull_p_L[match(i,Long),] <- summary(lmMultipleFull[[i]])$coefficients[,4]
}
# Full regression model for "short" houses
for (i in Short) {
print(paste('Full Model of Short house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleFull[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+MeanSeaLevelPressure+Radiation+AutumnBreak+ChristmasBreak+Weekend, data = model.tmp)
lmFull_est_S[match(i,Short),] <- summary(lmMultipleFull[[i]])$coefficients[,1]
lmFull_p_S[match(i,Short),] <- summary(lmMultipleFull[[i]])$coefficients[,4]
}
# Initializing a matrix containing empty strings for "long" houses
lmSummary_star_L <- matrix(rep('',17*length(Long)),nrow = length(Long))
# Adding signs and stars
for(i in 1:length(Long)){
for(j in 1:17){
if(lmFull_est_L[i,j]<0){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'-')
}else{
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'+')
}
if(lmFull_p_L[i,j]<0.05){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
if(lmFull_p_L[i,j]<0.01){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
}
if(lmFull_p_L[i,j]<0.001){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
}
}else if(lmFull_p_L[i,j]<0.1){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'.')
}
}
}
# Printing table
colnames(lmSummary_star_L) <- c("I","T","N","E","S","W","MeanSeaLvl","SolaR","WinterB","SpringB","AutumnB","ChristB","Weekend","T:N","T:E","T:S","T:W")
write.csv2(lmSummary_star_L, file = "lmMult_star_L.csv", row.names = TRUE)
star_count_L_array <- lmSummary_star_L
star_count_L_array <- gsub("\\.", "", star_count_L_array)
star_count_L_array <- nchar(star_count_L_array)
star_count_L_array <- star_count_L_array>3
colSums(star_count_L_array)
# Initializing a matrix containing empty strings for "short" houses
lmSummary_star_S <- matrix(rep('',15*length(Short)),nrow = length(Short))
for(i in 1:length(Short)){
for(j in 1:15){
if(lmFull_est_S[i,j]<0){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'-')
}else{
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'+')
}
if(lmFull_p_S[i,j]<0.05){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
if(lmFull_p_S[i,j]<0.01){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
}
if(lmFull_p_S[i,j]<0.001){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
}
}else if(lmFull_p_S[i,j]<0.1){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'.')
}
}
}
colnames(lmSummary_star_S) <- c("I","T","N","E","S","W","MeanSeaLvl","SolaR","AutumnB","ChristB","Weekend","T:N","T:E","T:S","T:W")
write.csv2(lmSummary_star_S, file = "lmMult_star_S.csv", row.names = TRUE)
star_count_S_array <- gsub("\\.", "", star_count_S_array)
star_count_S_array <- nchar(star_count_S_array)
star_count_S_array <- lmSummary_star_S
star_count_S_array <- star_count_S_array>3
colSums(star_count_S_array)
# General regression model for comparing houses ---------------------------
lmMultiple <- vector(mode="list", length = n)
lmMultipleNoP <- vector(mode = "list", length = n)
for (i in c(18,55)) {
print(paste('Modelling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
#  wd <- model.tmp$WindDirection[order(model.tmp$WindDirection)]
#  wd[wd<45] <- wd[wd<45]+360
tmp.wind <- Splinebasis*model.tmp$WindSpeed#[order(wd)]
#  tmp.wind <- model.tmp$WindSpeed[order(model.tmp$WindDirection)]
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lmMultipleNoP[[i]])
title(paste("Daily consumption for house ", i), outer=TRUE, adj = 0.5, line = -1.25)
# Testing for normality
sMultiple.test[[i]] <- shapiro.test(lmMultipleNoP[[i]]$residuals)
t[1,i]<-(sMultiple.test[[i]]$p.value)
sign.testM[[i]] <- binom.test(x = sum(sign(lmMultipleNoP[[i]]$residuals) == 1), n = length(lmMultipleNoP[[i]]$residuals))
t[2,i]<-(sign.testM[[i]]$p.value)
lmSummary_est[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,1]
lmSummary_p[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,4]
# Wind profile plot
par(mfrow = c(1,1))
model.Wind<-data.frame(Consumption=model.tmp$Consumption,Temperature=model.tmp$Temperature,Radiation=model.tmp$Radiation,N=model.tmp$North,E=model.tmp$East,S=model.tmp$South,W=model.tmp$West)
lmMultipleNoP[[i]] <- lm(Consumption ~ .+Temperature*(N + E + S + W),data = model.Wind)
Splinebasis2 <- BSplines(0:359)
newData = data.frame(Temperature = rep(0, 360), # 0 grader
Radiation = rep(0, 360), # Om natten
N = Splinebasis2[,3]*4.27, # Gennemsnitlig vindstyrke
E = Splinebasis2[,4]*4.27,
S = Splinebasis2[,1]*4.27,
W = Splinebasis2[,2]*4.27)
Wind.Pred[[i]]<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.95))
Wind.PredK<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.33))
plot(Wind.Pred[[i]]$fit,type='l',ylim=range(Wind.Pred[[i]]$lwr,Wind.Pred[[i]]$upr),main=paste("House: ",i),xlab = "Wind direction in degrees",ylab="Effect on consumption")
lines(Wind.Pred[[i]]$upr,lty=2)
lines(Wind.Pred[[i]]$lwr,lty=2)
abline(v=c(0,90,180,270,360), col="gray", lty=2, lwd=1)
CirclePlot(Wind.PredK)
title(main=paste("House: ",i))
}
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
par(mar=c(3,3,2,1), mgp=c(2,0.7,0),mfrow=c(1,1),xpd=FALSE)
source("data.R")
source("stepP.R")
source("BSplines.R")
source("CirclePlot.R")
# Initializing vectors containing "long" and "short" houses
k <-1:n
Long <- k[Datalengths>=360]
Short <- k[Datalengths<360]
#Flip WeatherCons
for(i in 1:n){
k<-dim(weatherCons[[i]])[1]
weatherCons[[i]]<-weatherCons[[i]][k:1,]
}
# Defining data used for modelling
model.data <- weatherCons
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
# Full regression model ---------------------------------------------------
# Initializing
lmMultipleFull <- vector(mode = "list", length = n)
lmFull_est_L <- matrix(rep(0,17*length(Long)),nrow = length(Long))
lmFull_p_L <- matrix(rep(0,17*length(Long)),nrow = length(Long))
lmFull_est_S <- matrix(rep(0,15*length(Short)),nrow = length(Short))
lmFull_p_S <- matrix(rep(0,15*length(Short)),nrow = length(Short))
# Full regression model for "long" houses
for (i in c(55,18)) {
print(paste('Full Model of long house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
# Splines
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleFull[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+MeanSeaLevelPressure+Radiation+WinterBreak+SpringBreak+AutumnBreak+ChristmasBreak+Weekend, data = model.tmp)
# Saving coefficients
lmFull_est_L[match(i,Long),] <- summary(lmMultipleFull[[i]])$coefficients[,1]
lmFull_p_L[match(i,Long),] <- summary(lmMultipleFull[[i]])$coefficients[,4]
}
# Full regression model for "short" houses
for (i in Short) {
print(paste('Full Model of Short house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleFull[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+MeanSeaLevelPressure+Radiation+AutumnBreak+ChristmasBreak+Weekend, data = model.tmp)
lmFull_est_S[match(i,Short),] <- summary(lmMultipleFull[[i]])$coefficients[,1]
lmFull_p_S[match(i,Short),] <- summary(lmMultipleFull[[i]])$coefficients[,4]
}
# Initializing a matrix containing empty strings for "long" houses
lmSummary_star_L <- matrix(rep('',17*length(Long)),nrow = length(Long))
# Adding signs and stars
for(i in 1:length(Long)){
for(j in 1:17){
if(lmFull_est_L[i,j]<0){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'-')
}else{
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'+')
}
if(lmFull_p_L[i,j]<0.05){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
if(lmFull_p_L[i,j]<0.01){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
}
if(lmFull_p_L[i,j]<0.001){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
}
}else if(lmFull_p_L[i,j]<0.1){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'.')
}
}
}
# Printing table
colnames(lmSummary_star_L) <- c("I","T","N","E","S","W","MeanSeaLvl","SolaR","WinterB","SpringB","AutumnB","ChristB","Weekend","T:N","T:E","T:S","T:W")
write.csv2(lmSummary_star_L, file = "lmMult_star_L.csv", row.names = TRUE)
star_count_L_array <- lmSummary_star_L
star_count_L_array <- gsub("\\.", "", star_count_L_array)
star_count_L_array <- nchar(star_count_L_array)
star_count_L_array <- star_count_L_array>3
colSums(star_count_L_array)
# Initializing a matrix containing empty strings for "short" houses
lmSummary_star_S <- matrix(rep('',15*length(Short)),nrow = length(Short))
for(i in 1:length(Short)){
for(j in 1:15){
if(lmFull_est_S[i,j]<0){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'-')
}else{
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'+')
}
if(lmFull_p_S[i,j]<0.05){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
if(lmFull_p_S[i,j]<0.01){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
}
if(lmFull_p_S[i,j]<0.001){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
}
}else if(lmFull_p_S[i,j]<0.1){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'.')
}
}
}
colnames(lmSummary_star_S) <- c("I","T","N","E","S","W","MeanSeaLvl","SolaR","AutumnB","ChristB","Weekend","T:N","T:E","T:S","T:W")
write.csv2(lmSummary_star_S, file = "lmMult_star_S.csv", row.names = TRUE)
star_count_S_array <- lmSummary_star_S
star_count_S_array <- gsub("\\.", "", star_count_S_array)
star_count_S_array <- nchar(star_count_S_array)
star_count_S_array <- star_count_S_array>3
colSums(star_count_S_array)
#summary(stepP(lmMultipleFull[[6]])$object)
#summary(lmMultipleFull[[6]])
# General regression model for comparing houses ---------------------------
lmMultiple <- vector(mode="list", length = n)
lmMultipleNoP <- vector(mode = "list", length = n)
lmSummary_est <- matrix(rep(0,11*n),nrow = n)
lmSummary_p <- matrix(rep(0,11*n),nrow = n)
Wind.Pred <- vector(mode = "list", length = n)
colnames(lmSummary_est) <- c("I","T","N","E","S","W","SolaR","T:N","T:E","T:S","T:W")
colnames(lmSummary_p) <- c("I","T","N","E","S","W","SolaR","T:N","T:E","T:S","T:W")
sMultiple.test <- vector(mode = "list", length = n)
sign.testM <- vector(mode = "list", length = n)
t<-matrix(rep(0,n*2),ncol=n)
par(mfrow = c(1,1))
for (i in c(18,55)) {
print(paste('Modelling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
#  wd <- model.tmp$WindDirection[order(model.tmp$WindDirection)]
#  wd[wd<45] <- wd[wd<45]+360
tmp.wind <- Splinebasis*model.tmp$WindSpeed#[order(wd)]
#  tmp.wind <- model.tmp$WindSpeed[order(model.tmp$WindDirection)]
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lmMultipleNoP[[i]])
title(paste("Daily consumption for house ", i), outer=TRUE, adj = 0.5, line = -1.25)
# Testing for normality
sMultiple.test[[i]] <- shapiro.test(lmMultipleNoP[[i]]$residuals)
t[1,i]<-(sMultiple.test[[i]]$p.value)
sign.testM[[i]] <- binom.test(x = sum(sign(lmMultipleNoP[[i]]$residuals) == 1), n = length(lmMultipleNoP[[i]]$residuals))
t[2,i]<-(sign.testM[[i]]$p.value)
lmSummary_est[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,1]
lmSummary_p[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,4]
# Wind profile plot
par(mfrow = c(1,1))
model.Wind<-data.frame(Consumption=model.tmp$Consumption,Temperature=model.tmp$Temperature,Radiation=model.tmp$Radiation,N=model.tmp$North,E=model.tmp$East,S=model.tmp$South,W=model.tmp$West)
lmMultipleNoP[[i]] <- lm(Consumption ~ .+Temperature*(N + E + S + W),data = model.Wind)
Splinebasis2 <- BSplines(0:359)
newData = data.frame(Temperature = rep(0, 360), # 0 grader
Radiation = rep(0, 360), # Om natten
N = Splinebasis2[,3]*4.27, # Gennemsnitlig vindstyrke
E = Splinebasis2[,4]*4.27,
S = Splinebasis2[,1]*4.27,
W = Splinebasis2[,2]*4.27)
Wind.Pred[[i]]<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.95))
Wind.PredK<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.33))
plot(Wind.Pred[[i]]$fit,type='l',ylim=range(Wind.Pred[[i]]$lwr,Wind.Pred[[i]]$upr),main=paste("House: ",i),xlab = "Wind direction in degrees",ylab="Effect on consumption")
lines(Wind.Pred[[i]]$upr,lty=2)
lines(Wind.Pred[[i]]$lwr,lty=2)
abline(v=c(0,90,180,270,360), col="gray", lty=2, lwd=1)
CirclePlot(Wind.PredK)
title(main=paste("House: ",i))
}
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lmMultipleNoP[[i]])
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lmMultipleNoP[[i]])
plot(lmMultipleNoP[[i]])
plot(lmMultipleNoP[[i]],main='')
plot(lmMultipleNoP[[i]])
title(paste("Daily consumption for house ", i), outer=TRUE, adj = 0.5, line = -1.25)
title(paste("Daily consumption for house", i), outer=TRUE, adj = 0.5, line = -1.25)
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lmMultipleNoP[[i]])
title(paste("Daily consumption for house", i), outer=TRUE, adj = 0.5, line = -1.25)
print(paste('Modelling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
#  wd <- model.tmp$WindDirection[order(model.tmp$WindDirection)]
#  wd[wd<45] <- wd[wd<45]+360
tmp.wind <- Splinebasis*model.tmp$WindSpeed#[order(wd)]
#  tmp.wind <- model.tmp$WindSpeed[order(model.tmp$WindDirection)]
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lmMultipleNoP[[i]])
title(paste("Daily consumption for house", i), outer=TRUE, adj = 0.5, line = -1.25)
