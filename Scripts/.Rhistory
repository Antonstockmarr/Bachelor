model.data <- weatherCons
for (i in 1:n) {
print(paste('Modeling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
lm.simple[[i]] <- lm(Consumption ~ Temperature, data = model.tmp)
#print(summary(lm.simple[[i]]))
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lm.simple[[i]])
title(paste("Daily consumption for house ", i, "using simple lm"), outer=TRUE, adj = 0.5, line = -1.25)
# Testing for normality
s.test[[i]] <- shapiro.test(lm.simple[[i]]$residuals)
print(s.test[[i]]$p.value)
#sign.test[[i]] <- binom.test(x = sum((sign(lm.simple[[i]]$residuals)+1)/2), n = length(lm.simple[[i]]$residuals))
sign.test[[i]] <- binom.test(x = sum(sign(lm.simple$residuals) == 1), n = length(lm.simple[[i]]$residuals))
print(sign.test[[i]]$p.value)
}
for (i in 1:n) {
print(paste('Modeling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
lm.simple[[i]] <- lm(Consumption ~ Temperature, data = model.tmp)
#print(summary(lm.simple[[i]]))
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
plot(lm.simple[[i]])
title(paste("Daily consumption for house ", i, "using simple lm"), outer=TRUE, adj = 0.5, line = -1.25)
# Testing for normality
s.test[[i]] <- shapiro.test(lm.simple[[i]]$residuals)
print(s.test[[i]]$p.value)
#sign.test[[i]] <- binom.test(x = sum((sign(lm.simple[[i]]$residuals)+1)/2), n = length(lm.simple[[i]]$residuals))
sign.test[[i]] <- binom.test(x = sum(sign(lm.simple[[i]]$residuals) == 1), n = length(lm.simple[[i]]$residuals))
print(sign.test[[i]]$p.value)
}
plot(Pred$fit,type='l',ylim=range(Pred$lwr,Pred$upr),main=mm)
lines(Pred$upr,lty=2)
lines(Pred$lwr,lty=2)
lines(ttd[[2]][[i]]$Consumption,lty=1,col=2)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
if(!exists("n")){
source("data.R")
}
source("TrainTest.R")
source("BSplines.R")
# Daily predictions ----------------------------------
k <-1:n
Long <- k[Datalengths>=360]
Short <- k[Datalengths<360]
# Defining data used for modeling
model.data <- weatherCons
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
ttd<-TrainTest(model.data,31)
lmMultipleNoP <- vector(mode = "list", length = n)
par(mfrow = c(1,1))
k<-0
for (i in c(Long,Short)) {
k<-k+1
if(k>length(Long)){
print(paste('Modeling long house ',i))
}else{
print(paste('Modeling short house ',i))
}
model.tmp <- ttd[[1]][[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
newData = ttd[[2]][[i]]
Splinetest <- BSplines(newData$WindDirection)
test.wind <- Splinetest*newData$WindSpeed
newData$North <- test.wind[,3]
newData$East <- test.wind[,4]
newData$South <- test.wind[,1]
newData$West <- test.wind[,2]
newData$Consumption<-NULL
Pred<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.95))
if(k>length(Long)){
mm<-paste("Short house: ",i)
}else{
mm<-paste("Long house: ",i)
}
plot(Pred$fit,type='l',ylim=range(Pred$lwr,Pred$upr),main=mm)
lines(Pred$upr,lty=2)
lines(Pred$lwr,lty=2)
lines(ttd[[2]][[i]]$Consumption,lty=1,col=2)
}
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
ttd<-TrainTest(model.data,31)
lmMultipleNoP <- vector(mode = "list", length = n)
par(mfrow = c(1,1))
k<-0
for (i in c(Long,Short)) {
k<-k+1
if(k>length(Long)){
print(paste('Modeling long house ',i))
}else{
print(paste('Modeling short house ',i))
}
model.tmp <- ttd[[1]][[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
newData = ttd[[2]][[i]]
Splinetest <- BSplines(newData$WindDirection)
test.wind <- Splinetest*newData$WindSpeed
newData$North <- test.wind[,3]
newData$East <- test.wind[,4]
newData$South <- test.wind[,1]
newData$West <- test.wind[,2]
newData$Consumption<-NULL
Pred<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.95))
if(k>length(Long)){
mm<-paste("Short house: ",i)
}else{
mm<-paste("Long house: ",i)
}
plot(Pred$fit,type='l',ylim=range(Pred$lwr,Pred$upr),main=mm)
lines(Pred$upr,lty=2)
lines(Pred$lwr,lty=2)
lines(ttd[[2]][[i]]$Consumption,lty=1,col=2)
legend(x = "topright", legend = c("Prediction", "95% CI", "Data"), lty = c(1,2,1), col = c(1,1,2))
}
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
par(mar=c(3,3,2,1), mgp=c(2,0.7,0))
source("data.R")
source("BBR.R")
library(ggplot2)
library(gridExtra)
library(tidyverse)
library(grid)
# Watts colors
Wcol=c(1,rgb(132,202,41,maxColorValue = 255),rgb(231,176,59,maxColorValue = 255),rgb(229,56,50,maxColorValue = 255))
# Example using Watts colors
plot(data[[1]]$Flow,col=Wcol[2])
# Average consumption -----------------------------------------------------
avgconsumption<-rep(0,difftime(max(EndDays),min(StartDays), units ="hours"))
weightavg<-rep(0,difftime(max(EndDays),min(StartDays), units ="hours"))
difftime(max(EndDays),min(StartDays), units ="hours")
avgconsumption[difftime(max(EndDays),min(StartDays), units ="hours")]
difftime(StartDays[1],min(StartDays), units ="hours")
difftime(EndDays[1],min(StartDays), units ="hours")
# Average consumption for all houses during a year
avg.plot1 <- ggplot(data = day.avg, mapping = aes(Date, Consumption)) + geom_point() +
ggtitle("Average consumption for all houses during a year ") + xlab("Time") +
ylab("Average consumption (kwh)") +
geom_smooth(col=Wcol[2], se = T)
# Selected houses based on wether they follow the trend
day.plot.flot <- ggplot(data = day.data[[18]], mapping = aes(Date, (CoolingDegree*Volume))) + geom_point() +
ggtitle(paste("Daily consumption for house 18")) + xlab("Time") +
ylab("Daily consumption (kwh)") +
geom_smooth(col=Wcol[2], se = T)
day.plot.gak <- ggplot(data = day.data[[42]], mapping = aes(Date, (CoolingDegree*Volume))) + geom_point() +
ggtitle(paste("Daily consumption for house 42")) + xlab("Time") +
ylab("Daily consumption (kwh)") +
geom_smooth(col=Wcol[2], se = T)
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
par(mar=c(3,3,2,1), mgp=c(2,0.7,0),mfrow=c(1,1),xpd=FALSE)
source("data.R")
source("stepP.R")
source("BSplines.R")
source("CirclePlot.R")
# Initializing vectors containing "long" and "short" houses
k <-1:n
Long <- k[Datalengths>=360]
Short <- k[Datalengths<360]
# Defining data used for modeling
model.data <- weatherCons
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
# Full regression model ---------------------------------------------------
# Initializing
lmMultipleFull <- vector(mode = "list", length = n)
lmFull_est_L <- matrix(rep(0,17*length(Long)),nrow = length(Long))
lmFull_p_L <- matrix(rep(0,17*length(Long)),nrow = length(Long))
lmFull_est_S <- matrix(rep(0,15*length(Short)),nrow = length(Short))
lmFull_p_S <- matrix(rep(0,15*length(Short)),nrow = length(Short))
# Full regression model for "long" houses
for (i in Long) {
print(paste('Full Model of long house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
# Splines
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleFull[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+MeanSeaLevelPressure+Radiation+WinterBreak+SpringBreak+AutumnBreak+ChristmasBreak+Weekend, data = model.tmp)
# Saving coefficients
lmFull_est_L[match(i,Long),] <- summary(lmMultipleFull[[i]])$coefficients[,1]
lmFull_p_L[match(i,Long),] <- summary(lmMultipleFull[[i]])$coefficients[,4]
}
# Full regression model for "short" houses
for (i in Short) {
print(paste('Full Model of Short house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleFull[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+MeanSeaLevelPressure+Radiation+AutumnBreak+ChristmasBreak+Weekend, data = model.tmp)
lmFull_est_S[match(i,Short),] <- summary(lmMultipleFull[[i]])$coefficients[,1]
lmFull_p_S[match(i,Short),] <- summary(lmMultipleFull[[i]])$coefficients[,4]
}
# Initializing a matrix containing empty strings for "long" houses
lmSummary_star_L <- matrix(rep('',17*length(Long)),nrow = length(Long))
# Adding signs and stars
for(i in 1:length(Long)){
for(j in 1:17){
if(lmFull_est_L[i,j]<0){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'-')
}else{
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'+')
}
if(lmFull_p_L[i,j]<0.05){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
if(lmFull_p_L[i,j]<0.01){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
}
if(lmFull_p_L[i,j]<0.001){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'*')
}
}else if(lmFull_p_L[i,j]<0.1){
lmSummary_star_L[i,j] <-paste(lmSummary_star_L[i,j],'.')
}
}
}
# Printing table
colnames(lmSummary_star_L) <- c("I","T","N","E","S","W","MeanSeaLvl","SolaR","WinterB","SpringB","AutumnB","ChristB","Weekend","T:N","T:E","T:S","T:W")
write.csv2(lmSummary_star_L, file = "lmMult_star_L.csv", row.names = TRUE)
star_count_L_array <- lmSummary_star_L
star_count_L_array <- gsub("\\.", "", star_count_L_array)
star_count_L_array <- nchar(star_count_L_array)
star_count_L_array <- star_count_L_array>3
colSums(star_count_L_array)
# Initializing a matrix containing empty strings for "short" houses
lmSummary_star_S <- matrix(rep('',15*length(Short)),nrow = length(Short))
for(i in 1:length(Short)){
for(j in 1:15){
if(lmFull_est_S[i,j]<0){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'-')
}else{
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'+')
}
if(lmFull_p_S[i,j]<0.05){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
if(lmFull_p_S[i,j]<0.01){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
}
if(lmFull_p_S[i,j]<0.001){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'*')
}
}else if(lmFull_p_S[i,j]<0.1){
lmSummary_star_S[i,j] <-paste(lmSummary_star_S[i,j],'.')
}
}
}
colnames(lmSummary_star_S) <- c("I","T","N","E","S","W","MeanSeaLvl","SolaR","AutumnB","ChristB","Weekend","T:N","T:E","T:S","T:W")
write.csv2(lmSummary_star_S, file = "lmMult_star_S.csv", row.names = TRUE)
star_count_S_array <- lmSummary_star_S
star_count_S_array <- gsub("\\.", "", star_count_S_array)
star_count_S_array <- nchar(star_count_S_array)
star_count_S_array <- star_count_S_array>3
colSums(star_count_S_array)
#summary(stepP(lmMultipleFull[[6]])$object)
#summary(lmMultipleFull[[6]])
# General regression model for comparing houses ---------------------------
lmMultiple <- vector(mode="list", length = n)
lmMultipleNoP <- vector(mode = "list", length = n)
lmSummary_est <- matrix(rep(0,11*n),nrow = n)
lmSummary_p <- matrix(rep(0,11*n),nrow = n)
Wind.Pred <- vector(mode = "list", length = n)
colnames(lmSummary_est) <- c("I","T","N","E","S","W","SolaR","T:N","T:E","T:S","T:W")
colnames(lmSummary_p) <- c("I","T","N","E","S","W","SolaR","T:N","T:E","T:S","T:W")
sMultiple.test <- vector(mode = "list", length = n)
par(mfrow = c(1,1))
par(mfrow = c(1,1))
for (i in 1:n) {
print(paste('Modeling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
#  wd <- model.tmp$WindDirection[order(model.tmp$WindDirection)]
#  wd[wd<45] <- wd[wd<45]+360
tmp.wind <- Splinebasis*model.tmp$WindSpeed#[order(wd)]
#  tmp.wind <- model.tmp$WindSpeed[order(model.tmp$WindDirection)]
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
#plot(lmMultipleNoP[[i]])
#title(paste("Daily consumption for house ", i), outer=TRUE, adj = 0.5, line = -1.25)
# Testing for normality
sMultiple.test[[i]] <- shapiro.test(lmMultipleNoP[[i]]$residuals)
#print(sMultiple.test[[i]]$p.value)
sign.testM[[i]] <- binom.test(x = sum(sign(lmMultipleNoP[[i]]$residuals) == 1), n = length(lmMultipleNoP[[i]]$residuals))
print(sign.testM[[i]]$p.value)
lmSummary_est[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,1]
lmSummary_p[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,4]
# Wind profile plot
par(mfrow = c(1,1))
model.Wind<-data.frame(Consumption=model.tmp$Consumption,Temperature=model.tmp$Temperature,Radiation=model.tmp$Radiation,N=model.tmp$North,E=model.tmp$East,S=model.tmp$South,W=model.tmp$West)
lmMultipleNoP[[i]] <- lm(Consumption ~ .+Temperature*(N + E + S + W),data = model.Wind)
Splinebasis2 <- BSplines(1:360)
newData = data.frame(Temperature = rep(0, 360), # 0 grader
Radiation = rep(0, 360), # Om natten
N = Splinebasis2[,3],
E = Splinebasis2[,4],
S = Splinebasis2[,1],
W = Splinebasis2[,2])
Wind.Pred[[i]]<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.25))
# plot(Wind.Pred[[i]]$fit,type='l',ylim=range(Wind.Pred[[i]]$lwr,Wind.Pred[[i]]$upr),main=paste("hus: ",i))
# lines(Wind.Pred[[i]]$upr,lty=2)
# lines(Wind.Pred[[i]]$lwr,lty=2)
# abline(v=c(0,90,180,270,360), col="gray", lty=2, lwd=1)
#
CirclePlot(Wind.Pred[[i]])
}
sign.testM <- vector(mode = "list", length = n)
par(mfrow = c(1,1))
for (i in 1:n) {
print(paste('Modeling house ',i))
model.tmp <- model.data[[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
#  wd <- model.tmp$WindDirection[order(model.tmp$WindDirection)]
#  wd[wd<45] <- wd[wd<45]+360
tmp.wind <- Splinebasis*model.tmp$WindSpeed#[order(wd)]
#  tmp.wind <- model.tmp$WindSpeed[order(model.tmp$WindDirection)]
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
# Checking model assumptions
par(mfrow = c(2,2), mar = c(3,3,3,1) + 0.1)
#plot(lmMultipleNoP[[i]])
#title(paste("Daily consumption for house ", i), outer=TRUE, adj = 0.5, line = -1.25)
# Testing for normality
sMultiple.test[[i]] <- shapiro.test(lmMultipleNoP[[i]]$residuals)
#print(sMultiple.test[[i]]$p.value)
sign.testM[[i]] <- binom.test(x = sum(sign(lmMultipleNoP[[i]]$residuals) == 1), n = length(lmMultipleNoP[[i]]$residuals))
print(sign.testM[[i]]$p.value)
lmSummary_est[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,1]
lmSummary_p[i,] <- summary(lmMultipleNoP[[i]])$coefficients[,4]
# Wind profile plot
par(mfrow = c(1,1))
model.Wind<-data.frame(Consumption=model.tmp$Consumption,Temperature=model.tmp$Temperature,Radiation=model.tmp$Radiation,N=model.tmp$North,E=model.tmp$East,S=model.tmp$South,W=model.tmp$West)
lmMultipleNoP[[i]] <- lm(Consumption ~ .+Temperature*(N + E + S + W),data = model.Wind)
Splinebasis2 <- BSplines(1:360)
newData = data.frame(Temperature = rep(0, 360), # 0 grader
Radiation = rep(0, 360), # Om natten
N = Splinebasis2[,3],
E = Splinebasis2[,4],
S = Splinebasis2[,1],
W = Splinebasis2[,2])
Wind.Pred[[i]]<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.25))
# plot(Wind.Pred[[i]]$fit,type='l',ylim=range(Wind.Pred[[i]]$lwr,Wind.Pred[[i]]$upr),main=paste("hus: ",i))
# lines(Wind.Pred[[i]]$upr,lty=2)
# lines(Wind.Pred[[i]]$lwr,lty=2)
# abline(v=c(0,90,180,270,360), col="gray", lty=2, lwd=1)
#
CirclePlot(Wind.Pred[[i]])
}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
if(!exists("n")){
source("data.R")
}
source("TrainTest.R")
source("BSplines.R")
# Daily predictions ----------------------------------
k <-1:n
Long <- k[Datalengths>=360]
Short <- k[Datalengths<360]
# Defining data used for modeling
model.data <- weatherCons
# Various attributes are removed
for (i in 1:n)
{
model.data[[i]]$Date <- NULL
model.data[[i]]$PrecipitationProbability <- NULL
model.data[[i]]$SunHour <- NULL
model.data[[i]]$UltravioletIndex <- NULL
model.data[[i]]$Condition <- NULL
}
ttd<-TrainTest(model.data,31)
lmMultipleNoP <- vector(mode = "list", length = n)
par(mfrow = c(1,1))
k<-0
for (i in c(Long,Short)) {
k<-k+1
if(k>length(Long)){
print(paste('Modeling long house ',i))
}else{
print(paste('Modeling short house ',i))
}
model.tmp <- ttd[[1]][[i]]
model.tmp <- model.tmp[model.tmp$Temperature <= 12,]
Splinebasis <- BSplines(model.tmp$WindDirection)
tmp.wind <- Splinebasis*model.tmp$WindSpeed
model.tmp$North <- tmp.wind[,3]
model.tmp$East <- tmp.wind[,4]
model.tmp$South <- tmp.wind[,1]
model.tmp$West <- tmp.wind[,2]
lmMultipleNoP[[i]] <- lm(Consumption ~ Temperature*(North + East + South + West)+
Radiation, data = model.tmp)
newData = ttd[[2]][[i]]
Splinetest <- BSplines(newData$WindDirection)
test.wind <- Splinetest*newData$WindSpeed
newData$North <- test.wind[,3]
newData$East <- test.wind[,4]
newData$South <- test.wind[,1]
newData$West <- test.wind[,2]
newData$Consumption<-NULL
Pred<-data.frame(predict(object=lmMultipleNoP[[i]], newdata=newData, interval = "confidence", level = 0.95))
if(k>length(Long)){
mm<-paste("Short house: ",i)
}else{
mm<-paste("Long house: ",i)
}
plot(Pred$fit,type='l',ylim=range(Pred$lwr,Pred$upr),main=mm)
lines(Pred$upr,lty=2)
lines(Pred$lwr,lty=2)
lines(ttd[[2]][[i]]$Consumption,lty=1,col=2)
legend(x = "topright", legend = c("Prediction", "95% CI", "Data"), lty = c(1,2,1), col = c(1,1,2))
}
source('~/Dropbox/DTU/6. semester/Bachelorprojekt F19/Bachelor/scripts/HourData.R', echo=TRUE)
install.packages("fields")
source('~/Dropbox/DTU/6. semester/Bachelorprojekt F19/Bachelor/scripts/HourData.R', echo=TRUE)
library('fields')
image.plot(t(tt[rev(order(row.names(tt))),]), axes=FALSE,
lab.breaks=NULL,main = 'Average consumption of all houses during the day')
axis(2, at=seq(1+1/48,0-1/48, length=13), labels=c('00','02','04','06','08','10','12','14','16','18','20','22','24'), lwd=0.1, pos=-0.01,las=1)
abline(h=c(seq(1,0, length=24)+1/48),lwd=0.75)
# Consumption in the summer period
for (i in 1:n)
{
SummerDays <- day.weather$Date[day.weather$Temperature >= 15]
tmp <- HourData[[i]]$Consumption[,'Date']
tmp_index <- sapply(tmp,function(x) x %in% SummerDays)
Houravg[,i] <- colMeans(HourData[[i]]$Consumption[tmp_index,],na.rm = TRUE)[-1]
Houravg[,i] <- Houravg[,i]/sum(Houravg[,i])
}
Houravg <- Houravg[c(2:24,1),]
summeravg <- Houravg
rownames(Houravg) <- c('00','01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23')
colnames(Houravg) <- c(1:n)
tt <- Houravg
image.plot(t(tt[rev(order(row.names(tt))),]), axes=FALSE,
lab.breaks=NULL,main = 'Average consumption of all houses (summer period)')
axis(2, at=seq(1+1/48,0-1/48, length=13), labels=c('00','02','04','06','08','10','12','14','16','18','20','22','24'), lwd=0.1, pos=-0.01,las=1)
abline(h=c(seq(1,0, length=24)+1/48),lwd=0.75)
mcons_summer <-apply(Houravg,1,mean)
#Finns plot
ttavg<-tt[,1]
for(i in 2:n){
ttavg<-ttavg+tt[,i]
}
ttavg<-ttavg/n
k=1:24
plot(k,ttavg,col=Wcol[3],pch=19,ylab ="% of avg consumption each hour",xlab="Hour")
points(k[ttavg>=quantile(ttavg)[4]],ttavg[ttavg>=quantile(ttavg)[4]],col=Wcol[4],pch=19)
points(k[ttavg<=quantile(ttavg)[2]],ttavg[ttavg<=quantile(ttavg)[2]],col=Wcol[2],pch=19)
abline(h=quantile(ttavg)[4],lty=2,col="gray")
abline(h=quantile(ttavg)[3],lty=2,col="gray")
abline(h=quantile(ttavg)[2],lty=2,col="gray")
